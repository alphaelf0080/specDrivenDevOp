# 🔧 問題修復說明

## 問題診斷

### 症狀
- ✅ Console 顯示正常執行（新增/刪除/保存都有日誌）
- ✅ 後端收到請求並成功保存
- ❌ **畫面沒有更新**（節點沒有顯示/消失）

### 根本原因

在 `MindMapCanvas.tsx` 中使用了 `initialized` 標記：

```tsx
const [initialized, setInitialized] = useState(false);

useEffect(() => {
  if (!initialized && initialNodes.length > 0) {
    setNodes(initialNodes);
    setEdges(initialEdges);
    setInitialized(true);  // ❌ 之後就不再更新了
  }
}, [initialNodes, initialEdges, initialized, setNodes, setEdges]);
```

**問題：**
- `initialized` 設為 `true` 後，即使 `initialNodes` 變化也不會更新
- 這個標記原本是為了防止拖曳回彈
- 但它同時也阻止了新增/刪除節點後的更新

## 解決方案

### 修改 `MindMapCanvas.tsx`

移除 `initialized` 標記，改用 **節點數量追蹤**：

```tsx
// 使用 ref 追蹤前一次的節點數量
const prevNodeCountRef = React.useRef(0);

useEffect(() => {
  const currentNodeCount = initialNodes.length;
  
  // 只在節點數量改變時更新（新增/刪除）
  if (prevNodeCountRef.current !== currentNodeCount) {
    console.log(`🔄 Node count changed: ${prevNodeCountRef.current} → ${currentNodeCount}`);
    setNodes(initialNodes);
    setEdges(initialEdges);
    prevNodeCountRef.current = currentNodeCount;
  }
}, [initialNodes, initialEdges, setNodes, setEdges]);
```

### 為什麼這樣可行？

1. **新增節點**：`initialNodes.length` 增加 → 觸發更新 ✅
2. **刪除節點**：`initialNodes.length` 減少 → 觸發更新 ✅
3. **拖曳節點**：`initialNodes.length` 不變 → **不觸發更新** ✅（避免回彈）
4. **樣式變更**：`initialNodes.length` 不變 → 不觸發更新（但樣式直接在本地 state 更新）✅

## 測試步驟

### 1. 重新整理瀏覽器
按 `Cmd+Shift+R`（Mac）或 `Ctrl+Shift+R`（Windows/Linux）

### 2. 開啟 Console（F12）

### 3. 測試新增節點
1. 右鍵點擊任一節點
2. 選擇「➕ 新增子節點」
3. **預期結果：**
   - Console 顯示：
     ```
     🆕 Adding new node to parent: xxx
     🔄 Node count changed: 27 → 28
     ✅ Node added, saving layout...
     ✅ Layout saved to server
     ```
   - **畫面上出現新節點** ✅

### 4. 測試刪除節點
1. 右鍵點擊剛才新增的節點
2. 選擇「🗑️ 刪除節點」
3. **預期結果：**
   - Console 顯示：
     ```
     🗑️ Deleting node: node-xxx
     🔄 Node count changed: 28 → 27
     ✅ Node deleted, saving layout...
     ✅ Layout saved to server
     ```
   - **節點從畫面上消失** ✅

### 5. 測試拖曳（確保沒有回彈）
1. 拖曳任一節點
2. 放開
3. **預期結果：**
   - 節點停留在新位置（**不回彈**）✅
   - Console 顯示：`✅ Layout saved to server`
   - **沒有** `🔄 Node count changed` 訊息（因為數量沒變）

### 6. 測試樣式編輯
1. 右鍵點擊節點
2. 選擇「🎨 編輯節點樣式」
3. 調整顏色並儲存
4. **預期結果：**
   - 樣式立即套用 ✅
   - Console 顯示：`✅ Layout saved to server`
   - 重新整理後樣式保留 ✅

## 預期的 Console 輸出

### 完整的操作流程

```
📍 Loading saved layout from server: 27 nodes

[新增節點]
🆕 Adding new node to parent: concept-sdd
🔄 Node count changed: 27 → 28
✅ Node added, saving layout...
✅ Layout saved to server

[刪除節點]
🗑️ Deleting node: node-1696584321234
🔄 Node count changed: 28 → 27
✅ Node deleted, saving layout...
✅ Layout saved to server

[拖曳節點 - 無 count changed]
✅ Layout saved to server

[編輯樣式 - 無 count changed]
✅ Layout saved to server
```

## 如果還是不行...

### 檢查清單

1. ✅ 確認前端已重新載入（硬重新整理）
2. ✅ 確認 Console 有 `🔄 Node count changed` 訊息
3. ✅ 確認後端正在運行
4. ✅ 清除瀏覽器快取

### 完全重啟

```bash
# 停止所有服務（Ctrl+C）

# 刪除快取和重新安裝
rm -rf node_modules package-lock.json
npm install

# 重新啟動
npm run dev:server  # 終端 1
npm run dev:client  # 終端 2
```

### 如果新節點出現但位置不對

這是正常的！新節點會通過 `dagre` 自動布局，可能出現在畫面外。
- **解決方法**：縮小畫面或使用滑鼠中鍵拖曳尋找
- 或點擊左下角的「Fit View」按鈕

## 技術細節

### 為什麼不用 `initialNodes` 的深度比較？

深度比較每次渲染都會執行，效能較差。而且：
- 拖曳時 `initialNodes` 會變化（位置改變）
- 樣式變更時 `initialNodes` 也會變化
- 這些情況下我們**不想**從 props 重新載入

### 為什麼用 `useRef` 而不是 `useState`？

- `useRef` 不會觸發重新渲染
- 只需要追蹤數值，不需要渲染到 UI
- 效能更好

### 拖曳為什麼不會回彈？

因為：
1. 拖曳只改變位置，不改變數量
2. `prevNodeCountRef.current !== currentNodeCount` 為 `false`
3. 不執行 `setNodes(initialNodes)`
4. 保留本地拖曳後的位置 ✅

## 相關修改

### 檔案：`MindMapCanvas.tsx`

**修改前：**
```tsx
const [initialized, setInitialized] = useState(false);

useEffect(() => {
  if (!initialized && initialNodes.length > 0) {
    setNodes(initialNodes);
    setEdges(initialEdges);
    setInitialized(true);
  }
}, [initialNodes, initialEdges, initialized, setNodes, setEdges]);
```

**修改後：**
```tsx
const prevNodeCountRef = React.useRef(0);

useEffect(() => {
  const currentNodeCount = initialNodes.length;
  
  if (prevNodeCountRef.current !== currentNodeCount) {
    console.log(`🔄 Node count changed: ${prevNodeCountRef.current} → ${currentNodeCount}`);
    setNodes(initialNodes);
    setEdges(initialEdges);
    prevNodeCountRef.current = currentNodeCount;
  }
}, [initialNodes, initialEdges, setNodes, setEdges]);
```

---

✅ **修復完成！現在新增和刪除節點應該可以正常顯示了！**
